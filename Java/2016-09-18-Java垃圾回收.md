---
layout:     post
title:      "JVM 垃圾回收详解"
date:       2016-09-18 20:45:10
author:     "afayp"
catalog:    true
tags:
    - Java
---

# JVM 垃圾回收详解

## Java内存模型
Java虚拟机规将JVM虚拟机所管理的内存分为以下几个部分：

<!--more>

![](https://user-gold-cdn.xitu.io/2016/12/9/dfd03f89c703b75324ab2d80a2444478)

1. 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行字节码的行号指示器。是线程私有，生命周期与线程相同。
2. Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。 Java虚拟机栈描述的是Java方法（区别于native的本地方法）执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动作链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  
3. 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机所使用到的Native方法服务。
4. Java堆：是虚拟机管理内存中最大的一块，被所有线程共享，该区域用于存放对象实例，几乎所有的对象都在该区域分配。Java堆是内存回收的主要区域，从内存回收角度看，由于现在的收集器大都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代，再细分一点的话可以分为Eden空间、From Survivor空间、To Survivor空间等。根据Java虚拟机规范规定，Java堆可以处于物理上不连续的空间，只要逻辑上是连续的就行。
5. 方法区：各个线程所共享的，用于存储已被虚拟机加载类信息、常亮、静态变量、即时编译器编译后的代码等数据。
6. 常量池，运行时常量池是方法区的一部分。存放类信息、常量、静态变量、编译器编译后的代码等数据。运行期间可以将新的常量放入常量池中，用得比较多的就是String类的intern()方法，当一个String实例调用intern时，Java查找常量池中是否有相同的Unicode的字符串常量，若有，则返回其引用；若没有，则在常量池中增加一个Unicode等于该实例字符串并返回它的引用。

关于内存模型更详细可参考[http://gityuan.com/2016/01/09/java-memory/]()

上面的几个部分，我们重点关注的是Java虚拟机栈和堆这两个。栈中主要保存了对象的引用，堆中保存了实际的对象，因此，实际上堆占了整个程序运行内存的大头，因此，内存回收就发生在堆中。

## 堆内存模型
前面已经简单介绍了堆内存模型，下面再详细介绍一下。
![](https://jayfeng.com/images/gc_heap.png)

- JVM将堆分成了二个大区:新生代和老年代。比例为1：2。  
- 新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。  
- 大多数新建的对象都位于Eden区。当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。
- 经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间
- 年老代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。Major GC会花费更多的时间。

## 可回收对象的判定
什么样的对象是垃圾（无用对象），需要被回收？目前市面上有两种算法用来判定一个对象是否为垃圾。

1. 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
![](https://jayfeng.com/images/gc_recycled_object.png)

优点是简单，高效。  
缺点是很难处理循环引用，比如图中相互引用的两个对象则无法释放

2. 可达性分析算法（根搜索算法）

为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。
从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。
![](https://jayfeng.com/images/gc_root_object.png)

这样即使循环引用了，只要没有被GC Roots引用了依然会被回收。
但是，这个GC Roots的定义就要考究了，Java语言定义了如下GC Roots对象：
> 
虚拟机栈（帧栈中的本地变量表）中引用的对象。  
方法区中静态属性引用的对象。  
方法区中常量引用的对象。  
本地方法栈中JNI引用的对象。  

## 引用
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。   
在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

在JDK 1.2之后，Java对引用的概念进行了扩充  
将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

- 强引用,类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用(SoftReference),用来描述一些还有用但并非必需的对象。在内存不足时会被回收，一般用来作为对象缓存。
- 弱引用(WeakReference),也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用(PhantomReference),最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## Stop the World
所有的垃圾收集都是“Stop the World”事件，因为所有的应用线程都会停下来直到操作完成（所以叫“Stop the World”）。


## 几种垃圾回收算法
知道哪些是垃圾对象了，怎么回收呢？目前主流有以下几种算法。

### 1.标记清除算法 (Mark-Sweep)

标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。  

优点是简单，容易实现。  
缺点是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。
示意图如下
![](https://user-gold-cdn.xitu.io/2016/12/9/f0a3493a126c3a3b4df3532f19c42301)

### 2.复制算法 (Copying)

复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。

优缺点就是，实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。  

从算法原理我们可以看出，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
示意图如下
![](https://user-gold-cdn.xitu.io/2016/12/9/84a424144df8ebea30166bf6f091f2fc)

### 3.标记整理算法 (Mark-Compact)

该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。
所以，特别适用于存活对象多，回收对象少的情况下。
![](https://user-gold-cdn.xitu.io/2016/12/9/84a424144df8ebea30166bf6f091f2fc)

### 4.分代回收算法
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。  
一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。
> 复制算法：适用于存活对象很少。回收对象多  
标记整理算法: 适用用于存活对象多，回收对象少

目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。

## 一些问题
- GC是在什么时候，对什么东西，做了什么事情？
什么时候？触发GC的时机: Eden区被对象填满时，就会执行Minor GC;老年代内存被占满时执行Major GC；  
对什么东西？对那些从gc root开始搜索，搜索不到的对象以及弱引用、虚引用对象；  
干什么？ 回收掉上面这些对象占据的内存空间。具体：在新生代做的是复制清理，把所有存活下来的对象转移到其中一个survivor区。老年代做的是标记整理，碎片整理等。

- 为什么Eden空间这么大而Survivor空间要分的少一点？  
新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。

- 从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？  
直接放到老年代去。

- Eden空间和两块Survivor空间的工作流程
现在假定有新生代Eden，Survivor A， Survivor B三块空间和老生代Old一块空间。
```
// 分配了一个又一个对象
放到Eden区
// 不好，Eden区满了，只能GC(新生代GC：Minor GC)了
把Eden区的存活对象copy到Survivor A区，然后清空Eden区（本来Survivor B区也需要清空的，不过本来就是空的）
// 又分配了一个又一个对象
放到Eden区
// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了
把Eden区和Survivor A区的存活对象copy到Survivor B区，然后清空Eden区和Survivor A区
// 又分配了一个又一个对象
放到Eden区
// 不好，Eden区又满了，只能GC(新生代GC：Minor GC)了
把Eden区和Survivor B区的存活对象copy到Survivor A区，然后清空Eden区和Survivor B区
// ...
// 有的对象来回在Survivor A区或者B区呆了比如15次，就被分配到老年代Old区
// 有的对象太大，超过了Eden区，直接被分配在Old区
// 有的存活对象，放不下Survivor区，也被分配到Old区
// ...
// 在某次Minor GC的过程中突然发现：
// 不好，老年代Old区也满了，这是一次大GC(老年代GC：Major GC)
Old区慢慢的整理一番，空间又够了
// 继续Minor GC
// ...
// ...
```

## 触发GC的类型

Java虚拟机会把每次触发GC的信息打印出来来帮助我们分析问题，所以掌握触发GC的类型是分析日志的基础。

- GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。
- GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。
- GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。
- GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。

## java堆内存开关
![](https://user-gold-cdn.xitu.io/2016/12/9/ee1bd3f4af67b1393e82760cd77daa56)



# Dalvik虚拟机和Art虚拟机
上面讲的是Java的JVM的垃圾回收机制，但是Android使用的虚拟机是Dalvik或者ART，两者在实现上有很多不同之处。

- JAVA虚拟机运行的是JAVA字节码，Dalvik虚拟机运行的是Dalvik字节码
- Dalvik可执行文件体积更小
- JVM基于栈，DVM基于寄存器  
JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费很多CPU时间。
Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式要快很多。
- Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码
Dalvik执行的是dex字节码，运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后在执行，但是将dex字节码翻译成本地机器码是发生在应用程序的运行过程中，并且应用程序每一次重新运行的时候，都要重新做这个翻译工作，相对浪费。  
安卓4.4开始使用ART虚拟机，在安装应用的时候，dex中的字节码将被编译成本地机器码，之后每次打开应用，执行的都是本地机器码。移除了运行时的解释执行，效率更高，启动更快。
> ART优点：  
①系统性能显著提升  
②应用启动更快、运行更快、体验更流畅、触感反馈更及时  
③续航能力提升  
④支持更低的硬件   
>
ART缺点  
①更大的存储空间占用，可能增加10%-20%  
②更长的应用安装时间

总的来说ART就是“空间换时间”


## 参考
[理解Java垃圾回收机制](https://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)  
[JAVA虚拟机、Dalvik虚拟机和ART虚拟机简要对比](http://blog.csdn.net/jason0539/article/details/50440669)