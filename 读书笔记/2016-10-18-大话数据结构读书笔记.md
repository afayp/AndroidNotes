---
layout:     post
title:      《大话数据结构》读书笔记
date:       2016-10-18 19:50:30
author:     "afayp"
catalog:    true
tags:
    - 读书笔记
    - 数据结构
---


# 一.数据结构绪论

### 什么是数据结构?
> 是互相之间存在一种或多种特定关系的数据元素的集合

按照视点的不同，分为逻辑结构和物理结构。

<!--more-->

### 逻辑结构
逻辑结构是指数据对象中数据元素之间的相互关系。  
逻辑结构又可分为：

- 集合结构：数据元素除了同属于一个集合外，没有其他关系，各元素是平等的。
- 线性结构：数据元素是一对一的关系（一个接一个）。
- 树形结构：一对多的层次关系
- 图形结构：多对多

### 物理结构
也叫存储结构，指的是数据在计算机中的存储形式。分两种：

- 顺序存储结构：数据元素存放在地址连续的存储单元里。
- 链式存储结构：数据元素存放在任意存储单元里，这组存储单元可以是连续的，也可以是不连续的。用一个指针存放数据元素的地址，这样通过地址就可以找到对应的位置。

逻辑结构是面向对象的，物理结构是面向计算机的。

数据结构的定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

# 二.算法
算法定义：
> 算法是解决特定问题求解步骤的描述。

算法特性：

- 输入输出：零个或多个输入，至少有一个或多个输出。
- 有穷性
- 确定性：每一步都有明确含义，不会有二义性
- 可行性

推导大O阶方法

1. 用常数1取代运行时间中所有加法常数
2. 在修改后的运行次数函数中，只保留最高位
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数
  得到的结果是大O阶

常见时间复杂度：

![](http://upload-images.jianshu.io/upload_images/2069346-5ada75e5d03628b6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 三.线性表
定义：
> 零个或多个数据元素的有限序列。

线性表可分为

- 顺序存储结构
- 链式存储结构

### 顺序存储结构
结构代码：

```
//顺序储存结构的结构代码：
#define MAXSIZE 20//储存空间的起始分配量
typedef int ElemType;//ElemType类型根据实际类型而定，这里假设是int
typedef struct{
	ElemType data[MAXSIZE];//数组储存元素，最大值为MAXSIZE
	int length;/线性表当前长度；
}SqList;
```

描述顺序存储结构三个属性：

1. 存储空间的起始位置：数组data,它的存储位置就是存储空间的储存位置； 
2. 最大储存量：MAXSIZE 
3. 线性表当前长度 length

线性表的顺序存储结构，查找时间复杂度为O(1);插入删除为O(n)；  

优点：快递存取表中任一位置元素。
缺点： 插入删除需要大量移动元素，长度变化时难以确定存储空间，造成碎片。

### 链式存储结构
用一组任意的存储单元（可连续可不连续）存储线性表的数据元素，每个元素除了要存储本身的信息外，还要存储它的后继元素的存储地址。

把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。

把链表中第一个结点的存储位置叫做头指针，整个链表的存取必须是从头指针开始进行，线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）


#### 单链表
单链表：n个节点链结成一个链表，每个结点只包含一个指针域。

有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。

单链表查找时间复杂度为O(n)，插入删除为O(1)

#### 单链表结构与顺序存储结构优缺点比较

##### 1. 存储分配方式：

顺序存储结构用一段连续的存储单元依次存储线性表的数据单元。

单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。   

##### 2. 时间性能：

查找：

- 顺序存储结构O(1)
-  单链表结构O(n)

插入和删除：

- 顺序存储结构需要平均移动表一半的元素 时间为 O(n)
- 单链表在计算出某位置的指针后，插入和删除时间为O(1)

##### 3. 空间性能：

- 顺序存储结构需要预分配存储空间，分大了，浪费空间，分小了，容易发生溢出。
- 单链表不需要分配存储空间，只要有就可以分配，元素个数不受限制。

##### 5. 结论

- 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。
- 若需要频繁插入和删除时，宜采用单链表结构。
- 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。
- 而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。”

#### 循环链表

将单链表中的终端结点的指针端由空指针改为指向头结点，链表就形成了一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

#### 双向链表
在单链表的每个结点中，在设置一个指向其前驱结点的指针域。所以每个结点都有两个指针域。

# 四.栈与队列

### 栈
定义：
> 限定仅在表尾进行插入和删除操作的线性表。

允许插入和删除的一端称为栈顶，另一端为栈底。后进先出(LIFO)，进栈(push),出栈(pop)

栈可分为顺序栈(顺序存储结构)和链栈(链式结构)。顺序栈和链栈的进栈出栈时间复杂度都为O(1)。

两者区别在于：如果元素变化不可预料，时大时小，用链栈；如果变化在可控范围内，用顺序栈。

对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。

栈的作用：递归、四则运算表达式求值


### 队列
定义：
> 只允许在一端进行插入操作，而在另一端进行删除操作的线性表.

先进先出(FIFO)，允许插入的一端称为队尾，允许删除的一端称为队头。

队列的头尾相接的顺序储存结构称为**循环队列**。 循环队列使得队头和队尾可以在数组中循环变化，避免了插入和删除时需要移动数据，时间复杂度由O（n）减小到O（1）   

队列的链式存储结构称为**链队列**。  

确定队列长度最大值的情况下用循环队列，否则用链队列。

# 五.串
定义：
> 由零个或多个字符组成的有限序列，又名叫字符串。

空串是指零个字符组成的串，可以用“”或者希腊字母Φ表示   

空格串是指只包含空格的串，可以不止一个空格。

串本质上是一种线性表的扩展，串的存储结构也可分为顺序存储结构和链式存储结构。

串的匹配：

- 朴素匹配算法:一个一个匹配。
- KMP模式匹配：利用已经匹配过的数据，创建一个next数组。避免重复遍历


# 六.树
定义
> 树是n(n>=0)个结点的有限集。n=0时称为空树。在任何一颗非空树中：
>
> 1. 有且仅有一个特定的称为根的结点
> 2. 当n>1时，其余结点可分为m（m>0）个互不相交的有限集t1、t2、......、tm，其中每一个集合本身又是一棵树，并且称为根的子树

- 结点拥有的子树数称为结点的度。树的度为树内各结点的最大值。
- 度为0的结点称为叶节点或终端结点。  
- 度不为0的结点称为分支结点或非终端结点。   
- 分支结点也称内部结点。  
- 结点的层次从根开始定义，根为第一层，树中结点的最大层次称为树的深度（高度）
- 将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树

### 树的存储结构：

1. 双亲表示法
  每个结点除了存储自身信息（数据域）外，还存储双亲结点在数组中的位置（指针域）。
2. 孩子表示法
3. 孩子兄弟表示法


### 二叉树
定义：
> 二叉树(Binary Tree)是n（n>=0)个结点的有限集合，该集合或者为空集（即称为空二叉树），或者由一个根结点两棵互不相交的，分别称为根结点的左子树和右子树的二叉树构成。

特点：

1. 每个结点最多有两棵子树； 
2. 左子树和右子树是有顺序的，不能任意颠倒； 
3. 即使某结点只有一棵子树，也要区分它是左子树还是右子树；

### 特殊二叉树：

1. 斜树：所有的结点只有左子树或只有右子树，分别称为左斜树和右斜树，统称为斜树 
2. 满二叉树：所有的分支结点都有左子树和右子树，并且所有的叶子都在同一层上（没有子树的结点称为叶结点（Leaf））  
  特点：   
  - 叶子（即叶结点）只能出现在最下一层；   
  - 同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多；
3. 完全二叉树： 对一棵二叉树按层序编号（从左到右），若每个结点的编号和同样深度的满二叉树的相同位置的结点的编号是相同的，则为完全二叉树； 

> 1. 满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。
> 2. 一个判断某二叉树是否是完全二叉树的办法，那就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不是完全二叉树，否则就是。

### 二叉树性质

1. 在二叉树的第i层上至多有2∧(i-1)个结点（i≥1）

2. 深度为k的二叉树至多有2∧k-1个结点（k≥1）

3. 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1

4. 具有n个结点的完全二叉树的深度为|log2n+1|（|x|表示不大于x的最大整数）

5. 如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有：

   1．如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点。

   2．如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。

   3．如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。


### 二叉树存储结构 

- 顺序存储结构：从根节点开始遍历二叉树，遇到没有则置空。一般只用于完全二叉树

- 二叉链表

  包含一个数据域和两个指针域（分别存放指向左孩子和右孩子的指针 ）
```c
typedef  struct BiTNode{
      TElemType data；
      struct BiTNode *lchild，*rchild；
} BiTNode，*BiTree；
```

### 二叉树遍历
定义： 
> 从根节点出发，按照某种次序访问二叉树中所有结点，每个结点被访问一次且仅被访问一次。

遍历方法

- 前序遍历：根左右
- 中序遍历：左根右
- 后序遍历：左右根
- 层序遍历：从第一层开始，从上而下逐层遍历，同一层中按从左到右的顺序。

### 线索二叉树
若在二叉树的每个结点中分别利用原本指向NULL的指针（度不为2的结点包含的指针）使其指向该结点的前驱和后继（这样的指针称为线索），则该二叉树称为线索二叉树。（相应的二叉链表称为线索链表）。

### 赫夫曼树

假设有n个权值{w1,w2,…,wn}构造一棵有n个结点的二叉树，每个叶子结点带权wk,每个叶子的路径长度为lk,我们通常记作，则其中带权路径长度WPL最小的二叉树称做赫夫曼树。


# 七. 图

定义： 
> 图（Graph）是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为：G(V,E),其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

- 线性表中的数据元素叫元素，树中叫结点，在图中数据元素叫顶点
- 没有数据元素的线性表称为空表，没有结点的树叫做空树，但图不允许没有顶点
- 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。
- 图中顶点集合V有穷非空，边集可以是空的


## 各种图的定义

- 无向边：(vi,vj)
- 有向边：<vi，vj>
- 简单图：不存在顶点到其自身的边，且同一条边不重复出现，则为简单图
- 无向（有向）完全图：任意两个顶点之间都存在边
- 权：与图的边或弧相关的数
- 网：带权的图
- 回路（环）：第一个顶点到最后一个顶点相同的路径
- 简单路径：顶点不重复出现的路径
- 连通图：图中任意两个顶点都是连通的
- 连通分量：无向图中的极大连通子图
- 强连通图：在有向图中，对于每一对vi，vj从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大连通子图称做有向图的强连通分量。


## 图的储存结构

- 邻接矩阵
- 邻接表
- 边集数组

## 图的遍历
- 深度优先遍历  
  从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发，深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到（邻接表）
- 广度优先遍历  
  类似于树的前序遍历（队列）


## 最小生成树

我们把构造连通网的最小代价生成树称为最小生成树（最小代价指的是n个顶点，用n-1条边把一个连通图连接起来，并使得权值的和最小）

- （普里姆）prim算法
- （克鲁斯卡尔）kruskal算法

最短路径

- （地杰斯特拉）dijkstr算法
- （弗洛伊德）floyd算法




# 八. 查找

查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。

查找表按照操作方式来分有两大种：静态查找表和动态查找表。

- 静态查找表（Static Search Table）：只作查找操作的查找表。

  它的主要操作有：（1）查询某个“特定的”数据元素是否在查找表中。（2）检索某个“特定的”数据元素和各种属性。

- 动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。

  显然动态查找表的操作就是两个：（1）查找时插入数据元素。（2）查找时删除数据元素。

#### 顺序查找

顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

>  时间复杂度为O(n)

####有序表查找

##### 1. 折半查找（二分查找）

它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。

>  折半算法的时间复杂度为O(logn)

##### 2. 插值查找

根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式(key-a[low])/(a[high]-a[low])。应该说，从时间复杂度来看，它也是O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{0,1,2,2000,2001,......,999998,999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。

##### 3.斐波那契查找 



#### 线性索引查找

索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。

索引按照结构可以分为线性索引、树形索引和多级索引。

所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。介绍三种线性索引：稠密索引、分块索引和倒排索引。

##### 1. 稠密索引 

稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，并且这些索引项也是有序的

##### 2. 分块索引

稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。

分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：

- 块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。
- 块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。

对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。

##### 3. 倒排索引

索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。

倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。缺点是这个记录号不定长，维护比较困难，插入和删除操作都需要作相应的处理。



#### 二叉树排序

二叉排序树（Binary Sort Tree），又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树。

二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状。



#### 平衡二叉树

平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。

平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。



#### 多路查找树

多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。

在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。为此，我们讲解它的4种特殊形式：2-3树、2-3-4树、B树和B+树。

##### 1. 2-3树

2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。

一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。

一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。

并且2-3树中所有的叶子都在同一层次上。如图8-8-2所示，就是一棵有效的2-3树。

##### 2. 2-3-4树

2-3-4树其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。

##### 3. B树

B树（B-tree）是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。

##### 4. B+树

B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。



#### 散列表查找（哈希表）概述

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）。查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上。

这里我们把这种对应关系f称为散列函数，又称为哈希（Hash）函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。那么关键字对应的记录存储位置我们称为散列地址。

##### 查找步骤

整个散列过程其实就是两步。

（1）在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。

（2）当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。

散列技术既是一种存储方法，也是一种查找方法。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。

散列技术最适合的求解问题是查找与给定值相等的记录。对于查找来说，简化了比较过程，效率就会大大提高。但万事有利就有弊，散列技术不具备很多常规数据结构的能力。比如同一个关键字对应多个记录的情况，需要范围查找的情况。

##### 哈希函数的构造

1. 直接定址法： f(key)=a×key+b（a、b为常数）
2. 数字分析法
3. 平方取中法
4. 折叠法
5. 除留余数法
6. 随机数法

##### 处理散列冲突

设计得再好的散列函数也不可能完全避免冲突，既然冲突不能避免，那就要考虑如何处理它。

1. 开发定址法

所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

2. 再散列函数法

事先准备多个散列函数，每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。

3. 链地址法

将所有关键字为同义词的记录存储在一个单链表中，这样就不存在什么冲突换址的问题，无论有多少个冲突，只需在当前位置给单链表增加结点。

链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。

4. 公共溢出区法

为所有冲突的关键字建立了一个公共的溢出区来存放。

在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。

##### 散列表的查找性能分析

如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为O(1)。可惜，我说的只是“如果”，没有冲突的散列只是一种理想，在实际的应用中，冲突是不可避免的。



# 九.排序

根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序

### 冒泡排序

冒泡排序（Bubble Sort）是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。

> 时间复杂度为O(n2)

#### 简单选择排序

通过n-i次关键字间的比较，从n-i＋1个记录中选出关键字最小的记录，并和第i（1≤i≤n）个记录交换之。

> 时间复杂度为O(n2)

#### 直接插入排序

#### 希尔排序

#### 堆排序

#### 归并排序

#### 快速排序



#### 排序比较

#### 性能对比

| 排序方式 | 平均情况            | 最好情况       | 最坏情况     | 辅助空间         | 稳定性  |
| ---- | --------------- | ---------- | -------- | ------------ | ---- |
| 冒泡排序 | O(n^2)          | O(n)       | O(n^2)   | O(1)         | 稳定   |
| 选择排序 | O(n^2)          | O(n^2)     | O(n^2)   | O(1)         | 稳定   |
| 插入排序 | O(n^2)          | O(n)       | O(n^2)   | O(1)         | 稳定   |
| 希尔排序 | O(nlogn)~O(n^2) | O(n^(3/2)) | O(1)     | O(1)         | 不稳定  |
| 堆排序  | O(nlogn)        | O(nlogn)   | O(nlogn) | O(1)         | 不稳定  |
| 归并排序 | O(nlogn)        | O(nlogn)   | O(nlogn) | O(n)         | 稳定   |
| 快速排序 | O(nlogn)        | O(nlogn)   | O(n^2)   | O(logn)~O(n) | 不稳定  |

- 从平均情况来看，最后 `3` 种改进算法要胜过希尔排序，并远远超过前 `3` 种简单算法；
- 从最好情况来看，冒泡和插入排序算法要比其他算法更胜一筹，也就是说如果待排序的序列基本有序，则可以选择这两种排序算法；
- 从最坏情况来看，堆排序和归并排序要由于快速排序以及其他简单排序；
- 从空间复杂度来看，除了归并排序和快速排序之外，其余算法对辅助空间的要求一致，都是 `O(1)`；如果排序过程中，对空间复杂度有要求，则建议选前面的 `5` 种排序算法；
- 从稳定性来看，改进算法中，只有归并排序是稳定的，而简单排序都是稳定的；
- 从待排序的记录的个数看，如果待排序的个数 `n` 越小，则采用简单排序算法比较合适；如果待排序的个数 `n` 越大，则采用改进排序算法更合适。

各种排序Java实现：[**10 大排序算法总结**](https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md)